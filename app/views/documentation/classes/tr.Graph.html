<classname name="tr.Graph" super="tr.Abstract" source="https://github.com/bvaughn/task-runner/blob/master/source/tr/graph.js"></classname>

<p class="lead">Executes a set of Tasks either in parallel or one after another.</p>

<p>
  This type of task allows a dependency graph (of child tasks) to be created.
  It then executes all of its children in the order needed to satisfy dependencies, and completes (or fails) once the child tasks have completed (or failed).
</p>

<p>
  In the event of an error, the graph will stop and error.
  All tasks that are running will be interrupted.
  If the graph is re-run, any incomplete child tasks will be resumed.
</p>

<usage source="app/snippets/documentation/graph.js"></usage>

<div class="bs-docs-constructor">
  <h4>
    <span class="label label-default">Constructor</span>
    tr.Graph(<em>taskName</em>)
  </h4>

  <signature params="[{name: 'taskName', optional: true, type: 'String', description: 'Optional task name.'}]"></signature>
</div>

<h3>Instance Methods</h3>

<!-- add() -->
<h4 class="page-header">
  add(task, <em>blockers</em>)
</h4>
<p>Adds a child task to the dependency graph and ensures that its blocking dependencies (if any) are valid.</p>
<signature params="[
  {name: 'task', type: 'tr.Task', description: 'Child task to be run when this task is run.'},
  {name: 'blockers', optional: true, type: 'Array<tr.Task>', description: 'Blocking tasks that must complete successfully before this task can be run. This parameter can be ommitted for tasks that do not have blocking dependencies.'}
]" return="{type: 'tr.Graph', description:'A reference to the current task'}"></signature>
<throws errors="[
  {type: 'Error', description: 'if task has been added more than once.'},
  {type: 'Error', description: 'if cyclic dependencies are detected.'}
]"></throws>

<!-- addAll() -->
<h4 class="page-header">
  addAll(tasks, <em>blockers</em>)
</h4>
<p>Adds child tasks to the dependency graph and ensures that their blocking dependencies (if any) are valid.</p>
<signature params="[
  {name: 'tasks', type: 'Array<tr.Task>', description: 'Child tasks to be run when this task is run.'},
  {name: 'blockers', optional: true, type: 'Array<tr.Task>', description: 'Blocking tasks that must complete successfully before this task can be run. This parameter can be ommitted for tasks that do not have blocking dependencies.'}
]" return="{type: 'tr.Graph', description:'A reference to the current task'}"></signature>
<throws errors="[
  {type: 'Error', description: 'if task has been added more than once.'},
  {type: 'Error', description: 'if cyclic dependencies are detected.'}
]"></throws>

<!-- addBlockersTo() -->
<h4 class="page-header">
  addBlockersTo(blockers, tasks)
</h4>
<p>Adds blocking dependencies (tasks) to tasks in the graph.</p>
<p>If the graph is running, blockers must not be added to tasks that are already running.</p>
<signature params="[
  {name: 'blockers', type: 'Array<tr.Task>', description: 'Blocking dependencies to add.'},
  {name: 'tasks', type: 'Array<tr.Task>', description: 'Tasks from which to add the blockers.'}
]" return="{type: 'tr.Graph', description:'A reference to the current task'}"></signature>
<throws errors="[
  {type: 'Error', description: 'if either the blockers or the tasks are not in the graph.'},
  {type: 'Error', description: 'if blockers have been added to tasks that are already running.'}
]"></throws>

<!-- addToEnd() -->
<h4 class="page-header">
  addToEnd(task)
</h4>
<p>
  Convenience method for adding a task to the "end" of the depepdency graph.
  In othe words, this task will be blocked by all tasks already in the graph.
</p>
<signature params="[{name: 'task', type: 'tr.Task', description: 'Child task to be run when this task is run.'}]"
           return="{type: 'tr.Graph', description:'A reference to the current task'}"></signature>
<throws errors="[{type: 'Error', description: 'if task has been added more than once.'}]"></throws>

<!-- remove() -->
<h4 class="page-header">
  remove(task)
</h4>
<p>Removes a child task from the dependency graph and ensures that the remaining dependencies are still valid.</p>
<signature params="[
  {name: 'task', type: 'tr.Task', description: 'Child task to be removed from the graph.'}
]" return="{type: 'tr.Graph', description:'A reference to the current task'}"></signature>
<throws errors="[
  {type: 'Error', description: 'if the task provided is not within the depenency graph.'},
  {type: 'Error', description: 'if removing the task invalidates any other, blocked tasks.'}
]"></throws>

<!-- removeAll() -->
<h4 class="page-header">
  removeAll(tasks)
</h4>
<p>Removes child tasks from the dependency graph and ensures that the remaining dependencies are still valid.</p>
<signature params="[
  {name: 'tasks', type: 'Array<tr.Task>', description: 'Child tasks to be removed.'}
]" return="{type: 'tr.Graph', description:'A reference to the current task'}"></signature>
<throws errors="[
  {type: 'Error', description: 'if the task provided is not within the depenency graph.'},
  {type: 'Error', description: 'if removing the task invalidates any other, blocked tasks.'}
]"></throws>

<!-- removeBlockersFrom() -->
<h4 class="page-header">
  removeBlockersFrom(blockers, tasks)
</h4>
<p>Removes blocking dependencies (tasks) from tasks in the graph.</p>
<p>If the graph is running, any newly-unblocked tasks will be automatically run.</p>
<signature params="[
  {name: 'blockers', type: 'Array<tr.Task>', description: 'Blocking dependencies to remove.'},
  {name: 'tasks', type: 'Array<tr.Task>', description: 'Tasks from which to remove the blockers.'}
]" return="{type: 'tr.Graph', description:'A reference to the current task'}"></signature>
<throws errors="[
  {type: 'Error', description: 'if either the blockers or the tasks are not in the graph.'}
]"></throws>

<h3>Protected methods</h3>

<!-- beforeFirstRun() -->
<h4 class="page-header">
  beforeFirstRun()
</h4>
<p>Subclasses may override this method to just-in-time add child Tasks before the composite is run.</p>